package wwe.modules.exploits;

import net.minecraft.entity.item.*;
import wwe.modules.*;
import org.lwjgl.opengl.*;
import me.THEREALWWEFAN231.wwefan.mixin.mixins.interfaces.*;
import wwe.utils.*;
import net.minecraft.network.play.server.*;
import wwe.commands.*;
import wwe.*;
import net.minecraft.entity.*;
import net.minecraft.util.math.*;
import net.minecraft.entity.player.*;

public class StrongHoldFinder extends qMIe
{
    public boolean woRB;
    public double LORk;
    public double SEXx;
    public float bQNq;
    public boolean kIpl;
    public double XJCI;
    public double dKXE;
    public float LJfS;
    public boolean LOvU;
    public BlockPos pXRY;
    public EntityEnderEye tuxC;
    public EntityEnderEye vzZn;
    public BooleanValue intersectionLines;
    public BooleanValue tracer;
    public int TsUq;
    
    public StrongHoldFinder() {
        super("Strong Hold Finder", "Finds a strong hold using two eyes of ender", 0, Category.EXPLOITS);
        this.LOvU = true;
        this.TsUq = 0;
    }
    
    @Override
    public void HrDr() {
        this.intersectionLines = new BooleanValue("Intersection Lines", this, "Draws where the ender eyes were going, may lag some computers", true);
        this.tracer = new BooleanValue("Tracer", this, "Draws a tracer to the strong holds location", true);
    }
    
    @oqrr
    public void PJlk(final RTIo rtIo) {
        if (this.intersectionLines.OnGi()) {
            GL11.glPushMatrix();
            GL11.glLoadIdentity();
            ((InterfaceMixinEntityRenderer)Wrapper.mc.entityRenderer).orientCameraVoid(rtIo.vCPg());
            GL11.glPushMatrix();
            GL11.glEnable(2848);
            GL11.glDisable(2929);
            GL11.glDisable(3553);
            GL11.glDepthMask(false);
            GL11.glBlendFunc(770, 771);
            GL11.glEnable(3042);
            GL11.glLineWidth(1.5f);
            final int n = 60000000;
            if (this.woRB) {
                GL11.glBegin(2);
                final double n2 = Math.cos(Math.toRadians(this.bQNq + 90.0f)) * n;
                final double n3 = Math.sin(Math.toRadians(this.bQNq + 90.0f)) * n;
                GL11.glColor4f(0.0f, 0.78431374f, 0.0f, 1.0f);
                GL11.glVertex3d(this.LORk - yYGD.onRX(), 0.0 - yYGD.UuJK(), this.SEXx - yYGD.LkVR());
                GL11.glVertex3d(this.LORk + n2 - yYGD.onRX(), 0.0 - yYGD.UuJK(), this.SEXx + n3 - yYGD.LkVR());
                GL11.glEnd();
            }
            if (this.kIpl) {
                GL11.glBegin(2);
                final double n4 = Math.cos(Math.toRadians(this.LJfS + 90.0f)) * n;
                final double n5 = Math.sin(Math.toRadians(this.LJfS + 90.0f)) * n;
                GL11.glColor4f(0.0f, 0.78431374f, 0.0f, 1.0f);
                GL11.glVertex3d(this.XJCI - yYGD.onRX(), 0.0 - yYGD.UuJK(), this.dKXE - yYGD.LkVR());
                GL11.glVertex3d(this.XJCI + n4 - yYGD.onRX(), 0.0 - yYGD.UuJK(), this.dKXE + n5 - yYGD.LkVR());
                GL11.glEnd();
            }
            GL11.glDisable(3042);
            GL11.glDepthMask(true);
            GL11.glEnable(3553);
            GL11.glEnable(2929);
            GL11.glDisable(2848);
            GL11.glPopMatrix();
            GL11.glPopMatrix();
            GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
        }
        if (this.tracer.OnGi() && this.pXRY != null) {
            GL11.glPushMatrix();
            GL11.glLoadIdentity();
            ((InterfaceMixinEntityRenderer)Wrapper.mc.entityRenderer).orientCameraVoid(rtIo.vCPg());
            GL11.glPushMatrix();
            GL11.glEnable(2848);
            GL11.glDisable(2929);
            GL11.glDisable(3553);
            GL11.glDepthMask(false);
            GL11.glBlendFunc(770, 771);
            GL11.glEnable(3042);
            GL11.glLineWidth(1.5f);
            final Vec3d rotateYaw = new Vec3d(0.0, 0.0, 1.0).rotatePitch(-(float)Math.toRadians(Wrapper.mc.player.rotationPitch)).rotateYaw(-(float)Math.toRadians(Wrapper.mc.player.rotationYaw));
            GL11.glBegin(2);
            GL11.glColor4f(0.0f, 0.78431374f, 0.0f, 1.0f);
            GL11.glVertex3d(rotateYaw.x, Wrapper.mc.player.getEyeHeight() + rotateYaw.y, rotateYaw.z);
            GL11.glVertex3d(this.pXRY.getX() - yYGD.onRX(), this.pXRY.getY() - yYGD.UuJK(), this.pXRY.getZ() - yYGD.LkVR());
            GL11.glColor4f(0.78431374f, 0.0f, 0.0f, 1.0f);
            GL11.glVertex3d(this.pXRY.getX() - yYGD.onRX(), this.pXRY.getY() + 255 - yYGD.UuJK(), this.pXRY.getZ() - yYGD.LkVR());
            GL11.glVertex3d(this.pXRY.getX() - yYGD.onRX(), this.pXRY.getY() - yYGD.UuJK(), this.pXRY.getZ() - yYGD.LkVR());
            GL11.glEnd();
            GL11.glDisable(3042);
            GL11.glDepthMask(true);
            GL11.glEnable(3553);
            GL11.glEnable(2929);
            GL11.glDisable(2848);
            GL11.glPopMatrix();
            GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
            GL11.glPopMatrix();
        }
    }
    
    @oqrr
    public void vIfM(final LqJY lqJY) {
        if (lqJY.MYlK() instanceof SPacketEntityVelocity) {
            final SPacketEntityVelocity sPacketEntityVelocity = (SPacketEntityVelocity)lqJY.MYlK();
            if (this.tuxC != null && sPacketEntityVelocity.getEntityID() == this.tuxC.getEntityId() && this.LOvU) {
                ++this.TsUq;
                if (this.TsUq > 6) {
                    this.LORk = Wrapper.mc.player.posX;
                    this.SEXx = Wrapper.mc.player.posZ;
                    this.bQNq = this.aADM((Entity)this.tuxC, Float.MAX_VALUE, Float.MAX_VALUE)[0];
                    this.tuxC = null;
                    this.TsUq = 0;
                    this.LOvU = false;
                }
            }
            else if (this.vzZn != null && sPacketEntityVelocity.getEntityID() == this.vzZn.getEntityId() && !this.LOvU) {
                ++this.TsUq;
                if (this.TsUq > 6) {
                    this.XJCI = Wrapper.mc.player.posX;
                    this.dKXE = Wrapper.mc.player.posZ;
                    this.LJfS = this.aADM((Entity)this.vzZn, Float.MAX_VALUE, Float.MAX_VALUE)[0];
                    this.vzZn = null;
                    this.LOvU = true;
                    this.TsUq = 0;
                    final int n = 60000000;
                    final BlockPos hIaK = this.HIaK(this.LORk, this.SEXx, this.LORk + Math.cos(Math.toRadians(this.bQNq + 90.0f)) * n, this.SEXx + Math.sin(Math.toRadians(this.bQNq + 90.0f)) * n, this.XJCI, this.dKXE, this.XJCI + Math.cos(Math.toRadians(this.LJfS + 90.0f)) * n, this.dKXE + Math.sin(Math.toRadians(this.LJfS + 90.0f)) * n);
                    if (hIaK == null) {
                        Command.TuzD("Ahh you did it incorrectly, thoses lines are parallel?, maybe watch this video, insert link here");
                        return;
                    this.pXRY = hIaK;
                    Command.TuzD("The strong hold should be around X: " + hIaK.getX() + " Z: " + hIaK.getZ() + ", if not maybe watch the help video in strong hold finder settings");
                }
            }
        }
    }
    
    @oqrr
    public void CgKG(final QRuA qRuA) {
        final Entity entityByID = Wrapper.mc.world.getEntityByID(qRuA.lORz().getEntityID());
        if (entityByID != null && entityByID instanceof EntityEnderEye) {
            final EntityEnderEye entityEnderEye = (EntityEnderEye)entityByID;
            if (this.LOvU) {
                this.tuxC = entityEnderEye;
                this.woRB = true;
                }
            }
            else {
                this.vzZn = entityEnderEye;
                this.kIpl = true;
            }
        }
    }
    
    @Override
    public void LPxx() {
        this.woRB = false;
        this.kIpl = false;
        this.LORk = 0.0;
        this.SEXx = 0.0;
        this.XJCI = 0.0;
        this.dKXE = 0.0;
        this.bQNq = 0.0f;
        this.LJfS = 0.0f;
        this.LOvU = true;
        this.tuxC = null;
        this.vzZn = null;
        this.pXRY = null;
        hSNE.lyvR(this);
    }
    
    @Override
    public void qBmy() {
        this.woRB = false;
        this.kIpl = false;
        this.LORk = 0.0;
        this.SEXx = 0.0;
        this.XJCI = 0.0;
        this.dKXE = 0.0;
        this.bQNq = 0.0f;
        this.LJfS = 0.0f;
        this.LOvU = true;
        this.tuxC = null;
        this.vzZn = null;
        this.pXRY = null;
        hSNE.kduK(this);
    }
    
    public float[] aADM(final Entity entity, final float n, final float n2) {
        final float n3 = 0.0f;
        final double n4 = entity.posX - Wrapper.mc.player.posX;
        final double n5 = entity.posZ - Wrapper.mc.player.posZ;
        double n6;
        if (entity instanceof EntityLivingBase) {
            final EntityLivingBase entityLivingBase = (EntityLivingBase)entity;
            n6 = entityLivingBase.posY + entityLivingBase.getEyeHeight() - (Wrapper.mc.player.posY + Wrapper.mc.player.getEyeHeight());
            }
        }
        else {
            n6 = (entity.getEntityBoundingBox().minY + entity.getEntityBoundingBox().maxY) / 2.0 - (Wrapper.mc.player.posY + Wrapper.mc.player.getEyeHeight());
        }
        final double n7 = MathHelper.sqrt(n4 * n4 + n5 * n5);
        final float n8 = (float)(Math.atan2(n5, n4) * 180.0 / 3.141592653589793) - 90.0f;
        final double n9 = n6;
        float n10;
        if (entity instanceof EntityPlayer) {
            n10 = n3;
            }
        }
        else {
            n10 = 0.0f;
        }
        return new float[] { this.qxzm(Wrapper.mc.player.rotationYaw, n8, n), this.qxzm(Wrapper.mc.player.rotationPitch, (float)(-(Math.atan2(n9 - n10, n7) * 180.0 / 3.141592653589793)), n2) };
    }
    
    public float qxzm(final float n, final float n2, final float n3) {
        float wrapDegrees = MathHelper.wrapDegrees(n2 - n);
        if (wrapDegrees > n3) {
            wrapDegrees = n3;
        }
        if (wrapDegrees < -n3) {
            wrapDegrees = -n3;
        }
        return n + wrapDegrees;
    }
    
    public BlockPos HIaK(final double n, final double n2, final double n3, final double n4, final double n5, final double n6, final double n7, final double n8) {
        final double n9 = n4 - n2;
        final double n10 = n - n3;
        final double n11 = n9 * n + n10 * n2;
        final double n12 = n8 - n6;
        final double n13 = n5 - n7;
        final double n14 = n12 * n5 + n13 * n6;
        final double n15 = n9 * n13 - n12 * n10;
        if (n15 == 0.0) {
            return null;
        }
        return new BlockPos((n13 * n11 - n10 * n14) / n15, 0.0, (n9 * n14 - n12 * n11) / n15);
    }
}
